---
title:  "전역 변수와 var의 문제점"
excerpt: "전역 변수와 var 키워드의 문제점을 알아본다. 그리고 그 해결 방안까지 살펴보자."
categories:
  - javascript
tags:
  - javascript
---

## 전역 변수

### 변수의 생명 주기

변수의 생명 주기라고 하면 메모리 공간을 확보allocate한 시점부터 메모리 공간이 해제release가 되어 가용 메모리 풀memory pool에 반환되는 시점까지이다. 이전 글에서 렉시컬 환경이라고 부르는 물리적인 스코프 실체가 있다고 했다. 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효하며 할당된 메모리 공간에 아무도 참조 하지 않게 되었을 때(누군가가 참조하고 있다면 확보된 상태로 남는다) 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 이는 스코프도 마찬가지이다.

호이스팅은 스코프를 단위로 동작하며 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작한다는 것을 의미한다. 아래 코드에서 보는 것처럼, `foo` 안에서 전역 스코프의 `a`를 참조하는 것이 아니라 호이스팅 된 지역 변수 `a`에 접근하여 자바스크립트 엔진의 암묵적 초깃값인 undefined가 출력된다.

```js
const a = 'global'

function foo() {
  console.log(a); // undefined
  var a = 'local' // 함수 foo의 생명 주기와 일치한다.
}

foo();
console.log() // 'global'
```

함수가 호출되어 실행 후 종료하면 나면 함수 내부의 지역 변수도 소멸된다. 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.



### 전역 코드

함수와 달리 전역 코드는 자바스크립트에서 명시적인 호출 없이 바로 실행된다. C나 java와 같은 언어의 `main`함수 처럼 특별한 진입점이 없으므로 코드가 로드되자마자 바로 해석되어 실행된다.



### 전역 변수의 문제점

전역 변수는 모든 코드에서 해당 변수를 참조할 수 있는 암묵적 결합implicit coupling을 의미한다. 코드의 가독성이 나빠질 뿐만 아니라 의도치 않게 상태가 변경될 수도 있다. 전역 변수의 생명 주기는 길기 때문에 앞서 말한 것 처럼 의도치 않게 상태가 변경할 위험에 오래 노출될 뿐만 아니라 네임스페이스를 오염시키며  메모리 리소스 또한 오랜 기간 점유하게 된다. 또한 모든 스코프 체인에서 접근할 수 있는데 전역 변수의 검색이 가장 마지막에 이루어지므로 전역 변수의 검색 속도 또한 느리다.



### 전역 변수 사용 억제하기

변수의 스코프는 좁을 수록 좋으며 전역 변수 사용을 억제해야 한다. 즉시 실행 함수를 사용하여 변수를 즉시 실행 함수의 지역 변수로 만드는 방법이 있다. 이는 전역 변수를 생성하지 않으므로 라이브러리에서 자주 사용하는 방식이다. 네임스페이스 오염 방지를 위해 전역에 아래와 같은 네임스페이스 객체를 만드는 것도 방법이 될 수 있지만 단순히 식별자 충돌만 방지하는 효과만 있으며 여전히 객체가 전역변수로 존재한다.

```js
const MYAPP = {};

MYAPP.myKey = 'hello';
```

클로저를 활용하여 모듈 패턴으로 클래스를 모방해서 전역 변수의 억제를 막을 수 있다. 클래스와 클로저에 대해서는 추후에 다룰 것이다. 다른 방법으로는 ES6 모듈을 사용하여 파일 자체의 독자적인 모듈 스코프를 사용하는 방법으로 전역 변수 사용을 제한하는 방법이 있다.



## var, let, const

### var의 문제점

`var`를 사용하여 변수를 선언하게 되면 중복 선언을 허용하며 함수 레벨 스코프라는 점 때문에 주의를 기울이지 않으면 개발자가 의도치 않은 부작용을 발생시킬 수 있는 가능성이 있었다. 또한 `var`을 사용한 변수 선언문 이전에 해당 변수를 참조할 수 있어 가독성을 떨어뜨리고 마찬가지로 오류를 발생시킬 여지가 생기게 된다.

### let, const

이러한 `var`의 단점을 보완하기 위해 ES6에는 `let`과 `const`라는 변수 선언 키워드가 도입되었다. `let`과 `const`로 선언된 변수는 아래와 같은 공통점을 가진다.

1. 변수 중복 선언시 문법 에러SyntaxError를 발생시킨다.
2. 블록 레벨 스코프를 따른다.
3. 선언 이전에 참조할 수 없으며 변수 선언문 이전에 참조할 수 없으며 참조할 경우 참조 에러ReferenceError를 발생시켜 마치 호이스팅이 발생하지 않는 것처럼 동작한다.

`var`는 런타임 이전에 선언단계와 초기화 단계가 동시에 진행되어 `undefined`로 초기화된다. 그러나 `let`의 경우 선언 단계화 초기화 단계가 분리되어 진행되며 초기화 단계의 경우 변수 선언문에 도달했을 때 이루어지게 된다. 따라서 선언 이전에 참조할 경우 값이 없기 때문에 참조 에러가 발생하게 된다. 이 때 선언단계와 초기화 단계 사이를 일시적 사각지대(TDZ: temporal dead zone)이라고 부른다. `const`도 마찬가지이다.

```js
let foo = 1; // 전역 변수

{
  // let, const도 스코프에서 호이스팅은 일어나고 있다. 
  // 그렇지 않다면 전역 변수 foo를 스코프 체인에서 찾아 1이 출력될 것이다.
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

`const`의 경우 `let`과 다르게 선언문에 반드시 초기화가 동시에 이루어져야 하며 재할당이 불가능하다. `const`로 선언될 경우 재할당이 불가능하기 때문에 원시값으로 초기화된 경우에는 값을 변경할 수 없다는 뜻이지만, 객체로 초기화 된 경우 변경 가능한 값인 객체의 값은 변경할 수 있다. 즉, 불변을 의미하는 것이 아니라 완전히 새로운 할당(재할당)을 금지하는 것이다.

