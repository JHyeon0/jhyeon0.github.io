---
title:  "함수와 스코프"
excerpt: "자바스크립트 함수 선언문과 함수 표현식 그리고 스코프에 대해서 알아본다."
categories:
  - javascript
tags:
  - javascript
---

## 함수

함수는 일련의 과정을 문으로 구현하여 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 자바스크립트에서 함수는 개체 타입의 값으로 함수 리터럴은 값으로 평가가 가능하다. 함수는 객체이지만 일반 객체와 달리 호출할 수 있으며 함수 객체만의 고유한 프로퍼티를 갖게 된다.

```js
// 함수 리터럴을 변수에 할당
const foo = function add(a,b){ 
  return a+b; 
}
```

자바스크립트에서 함수를 정의하는 방법은 크게 네 가지이다. 먼저 함수 선언문과 함수 표현식의 차이를 살펴보자.

```js
// 함수 선언문
function add1(a,b){ 
  return a+b; 
}

// 함수 표현식
const foo = function add(a,b){ 
  return a+b; 
}

// Function 생성자 함수
const boo = new Function('a', 'b', 'return a+b')

// ES6 화살표 함수
const add4 = (a,b) => a+b;
```

### 함수 선언문과 함수 표현식

함수 선언문은 표현식이 아닌 문으로 값으로 평가가 되지 않고 실행하면 완료 값 undefined가 출력된다. 하지만 함수 표현식의 형태를 보면 함수 선언문이 표현식처럼 사용되어 변수에 할당되고 있다. 이는 자바스크립트 엔진에 **코드의 문맥에 따라 똑같은 코드라도 함수 선언문으로 해석할지 혹은 함수 리터럴로 해석을 할지 결정**하기 때문이다. 이와 동일하게 자바스크립트에서 `{ }`는 코드 블록일 수도 있지만 문맥상 객체 리터럴로 해석될 수도 있다.

아래코드에서 `foo`는 그룹연산자(소괄호)로 인해 함수 선언문이 아니라 함수 리터럴로 해석되기 때문에 `foo`는 함수 몸체 내에서만 참조할 수 있는 식별자가 된다.

```js
(function foo(){console.log('foo')})

foo() // ReferenceError: foo is not defined
```

함수 선언문의 경우 자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 그 식별자에 함수 객체를 할당한다. 아래 코드에서 사실 `add` 함수 이름은 함수 몸체 내부에서만 유효하여 바깥에서 `add`를 호출할 수 없어야 한다. 하지만 자바스크립트 엔진이 암묵적으로 함수 이름과 같은 이름으로 함수 객체를 가리키는 식별자를 만들어 준다. 따라서 사실은 함수를 호출 할 때 함수 이름으로 호출하는 것이 아니라 식별자로 호출하는 것이다.

```js
// 함수 선언문
function add(a,b) {
  return a+b
}
```

여기까지 보면 사실상 함수 선언문과 함수 표현식이 비슷하게 동작하는 것처럼 보인다.

```js
// 함수 표현식
const add = function add(a,b) {
  return a+b
}
```

하지만 **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다르다**. 함수 선언문은 런타임 이전에 함수 객체가 생성되어 함수 선언문 이전에 해당 함수를 참조할 수 있다(함수 호이스팅). `var`의 변수 호이스팅과는 다르게 undefined로 초기화 되는 것이 아니라 함수 객체로 초기화된다. 함수 표현식의 경우 변수에 할당되는 값이 함수 리터럴일 뿐이다. 따라서 변수 할당문처럼 undefined로 초기화되고 런타임에 함수 리터럴이 평가되어 함수 객체가 변수에 할당된다. 즉, 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

```js
// 함수 참조
console.log(add1) // f add1()
console.log(add2) // undefined

// 함수 호출
add1(1,2) // 3
add2(4,5) // TypeError: add2 is not a function

// 함수 선언문
function add1(a,b) {
  return a + b;
}

// 함수 표현식
var add2 = function(a,b) {
  return a + b;
}
```



## 스코프

### 스코프란?

변수 이름, 함수 이름, 클래스 이름 등 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 그 식별자를 참조할 수 있는 유효 범위가 결정되며 이를 스코프라고 한다. 즉, **식별자가 유효한 범위를 스코프라고 부른다**. 자바스크립트 엔진의 입장에서 코드의 식별자를 만나면 코드의 문맥을 고려하여 식별자 결정을 유일하게 해야한다. 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 렉시컬 환경lexical environment라고 부르며 이러한 코드의 문맥을 구현한 것을 실행 컨텍스트execution context라고 부른다. 모든 코드는 이 실행 컨텍스트에서 평가되어 실행되는데 이에 대해서는 추후 더 자세히 다룰 것이다.

변수를 참조하려고 할 때 자바스크립트 엔진은 스코프가 계층적으로 연결된 스코프 체인에서 해당 변수가 있는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이러한 스코프 체인은 물리적으로 실체가 존제하여 렉시컬 환경을 생성하게 된다. 상위 스코프에서 유효한 변수는 하위 스코프에서(좁은 스코프에서) 참조할 수 있지만 상위 스코프에서는 하위 스코프에서 참조할 수 없다. 

이러한 스코프를 나누는 기준을 오로지 함수의 코드 블록으로 인정하는 것을 함수 레벨 스코프라고 한다. 하지만 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)을 지역스코프로 나누며 이러한 것을 블록 레벨 스코프라고 부른다. `var`의 경우 함수 코드 블록만을 스코프로 인정하기 때문에 아래와 같은 결과가 나타날 수 있다.

```js
var i = 20;

for(var i=0; i<10; i++){
  console.log(i); 0, 1, 2, 3..., 9
}

// for문에 의해 i 값이 변경되어 버렸다.
console.log(i); // 10
```

### 렉시컬 스코프

함수의 스코프를 결정할 때 아래와 같은 두 가지 방식을 생각해 볼 수 있다.

1. 함수를 호출한 곳에 의해 해당 함수의 상위 스코프 결정
2. 함수를 정의한 곳에 의해 해당 함수의 상위 스코프 결정

```js
const a = 'global';

function foo() {
  const a = 'foo';
  bar();
}

function bar() {
  console.log(a)
}

foo() // 'global'
bar() // 'global'
```

자바스크립트를 비롯한 대부분의 프로그래밍 언어는 두 번째 방식을 취하고 있으며 이를 렉시컬 스코프lexical scope 혹은 정적 스코프static scope라고 부른다. **함수의 호출 위치와는 무관하게 함수 정의가 어디서 이루어 졌느냐에에 의해서만 스코프가 결정**된다. 반대로 첫 번째 방식을 동적 스코프dynamic scope라고 부르며 함수가 호출될 때 동적으로 상위 스코프가 결정된다. 이에 관해서는 추후 클로저와 함께 더 다루어 볼 것이다.



